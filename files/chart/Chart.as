package {		import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;		public class Chart extends Sprite {				private static const TOP_MARGIN:int = 10;		private static const HORIZONTAL_AXIS_HEIGHT:int = 30;		private static const VERTICAL_AXIS_WIDTH:int = 75;		private static const LEGEND_WIDTH:int = 150;				private var data:XML;		private var axes:Axes;		private var grid:Grid;		private var series:Array;		private var legend:Legend;		private var tip:Tip;				public function Chart(data:XML) {			this.data = data;			addEventListener(Event.ADDED_TO_STAGE, init);		}				private function init(event:Event):void {			initLegend();			initAxes();			initGrid();			parseSeries(data.series);			initTip();			addEventListener(TipEvent.SHOW, onShowTip);			addEventListener(TipEvent.HIDE, onHideTip);			addEventListener(SeriesEvent.REMOVE, onRemoveSeries);			stage.addEventListener(MouseEvent.MOUSE_MOVE, onMouseMove);		}				private function initAxes():void {			axes = new Axes(stage.stageWidth - VERTICAL_AXIS_WIDTH - LEGEND_WIDTH, HORIZONTAL_AXIS_HEIGHT,								  VERTICAL_AXIS_WIDTH, stage.stageHeight - HORIZONTAL_AXIS_HEIGHT - TOP_MARGIN);			axes.y = TOP_MARGIN;			addChild(axes);		}				private function parseSeries(data:XMLList):void {			series = new Array();			for each (var date:XML in data) {				addSeries(date);			}		}				public function addSeries(data:XML):void {			var s:Series = new Series(data, axes, series.length);			axes.updateExtremes(s.getHorizontalMin(), s.getVerticalMin());			axes.updateExtremes(s.getHorizontalMax(), s.getVerticalMax());			s.x = VERTICAL_AXIS_WIDTH;			s.y = TOP_MARGIN;			series.push(s);			addChild(s);			if (tip != null && contains(tip)) {				removeChild(tip);				addChild(tip);			}		}				private function initGrid():void {			grid = new Grid(stage.stageWidth - VERTICAL_AXIS_WIDTH - LEGEND_WIDTH, stage.stageHeight - HORIZONTAL_AXIS_HEIGHT - TOP_MARGIN);			grid.x = VERTICAL_AXIS_WIDTH;			grid.y = TOP_MARGIN;			addChild(grid);		}				private function initLegend():void {			legend = new Legend(LEGEND_WIDTH, stage.stageHeight);			legend.x = stage.stageWidth - LEGEND_WIDTH;			addChild(legend);		}				private function initTip():void {			tip = new Tip();			addChild(tip);		}				public function draw():void {			axes.draw();			for each (var s:Series in series) {				s.draw();			}		}				public function addItem(data:XML):void {			var item:Item = series[0].addItem(data);			axes.updateExtremes(item.getH(), item.getV());			draw();		}				private function onShowTip(event:TipEvent):void {			tip.show(event.getTip());			var tipX:int = event.getX() + VERTICAL_AXIS_WIDTH;			if (tipX + tip.width > stage.stageWidth) tipX -= tip.width;			var tipY:int = event.getY() - tip.height - 10 + TOP_MARGIN;			if (tipY < 0) tipY = event.getY() + 10 + TOP_MARGIN;			tip.move(tipX, tipY);		}				private function onHideTip(event:TipEvent):void {			tip.hide();		}				private function onMouseMove(event:MouseEvent):void {			var closest:Array = new Array();			for each (var s:Series in series) {				var c:Item = s.getClosest();				if (c != null) closest.push(c);			}			if (closest.length > 0) closest.sortOn("distance", Array.NUMERIC)[0].select();		}				private function onRemoveSeries(event:SeriesEvent):void {			for (var i:uint = 1; i < series.length; i++) {				if (series[i] == event.getSeries()) {					series.splice(i, 1);					removeChild(event.getSeries());					axes.resetExtremes();					for each (var s:Series in series) {						axes.updateExtremes(s.getHorizontalMin(), s.getVerticalMin());						axes.updateExtremes(s.getHorizontalMax(), s.getVerticalMax());					}					draw();					break;				}			}		}			}	}