package {		import flash.display.Sprite;	import flash.display.Stage;	import flash.geom.Point;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.external.ExternalInterface;		public class Chart extends Sprite {				private static const HORIZONTAL_AXIS_HEIGHT:int = 30;		private static const VERTICAL_AXIS_WIDTH:int = 90;		private static const LEGEND_WIDTH:int = 150;				private var w:int;		private var h:int;		private var axes:Axes;		private var grid:Grid;		private var series:Array;		private var legend:Legend;		private var tip:Tip;				public function Chart(w:int, h:int, stage:Stage) {			this.w = w;			this.h = h;			series = new Array();			initAxes();			initGrid();			initLegend();			initTip();			addEventListener(TipEvent.SHOW, onShowTip);			addEventListener(TipEvent.HIDE, onHideTip);			addEventListener(SeriesEvent.REMOVE, onRemoveSeries);			stage.addEventListener(MouseEvent.MOUSE_MOVE, onMouseMove);		}				private function initAxes():void {			axes = new Axes(w - VERTICAL_AXIS_WIDTH - LEGEND_WIDTH, HORIZONTAL_AXIS_HEIGHT, VERTICAL_AXIS_WIDTH, h - HORIZONTAL_AXIS_HEIGHT);			addChild(axes);		}				private function initGrid():void {			grid = new Grid(axes.getHorizontal().getWidth(), axes.getVertical().getHeight());			grid.x = axes.getVertical().getWidth();			addChild(grid);		}				private function initLegend():void {			legend = new Legend(axes.getWidth(), h);			legend.x = w - axes.getWidth();			addChild(legend);		}				private function initTip():void {			tip = new Tip();			addChild(tip);		}				public function addSeries(data:XML, deletable:Boolean = true):void {			var s:Series = new Series(data, deletable, axes, series.length);			if (s.hasItems()) axes.getVertical().updateExtremes(s.getVerticalMin(), s.getVerticalMax());			s.x = axes.getVertical().getWidth();			series.push(s);			addChild(s);			if (contains(tip)) {				removeChild(tip);				addChild(tip);			}		}				public function addItem(data:XML):void {			var item:Item = series[0].addItem(data, true);			axes.getVertical().updateExtremes(item.getV(), item.getV());		}				public function setItemCount(count:int):void {			axes.getHorizontal().setItemCount(count);			axes.getVertical().resetExtremes();			for each (var s:Series in series) {				if (s.hasItems()) axes.getVertical().updateExtremes(s.getVerticalMin(), s.getVerticalMax());			}			draw();		}				public function getMaxItemCount():int {			var max:int = 1;			for each (var s:Series in series) {				if (s.getItemCount() > max) max = s.getItemCount();			}			return max;		}				public function draw():void {			axes.draw();			for each (var s:Series in series) {				s.draw();			}			onMouseMove();		}				private function onShowTip(event:TipEvent):void {			tip.show(event.getTip());			tip.move(getTipPosition(event.getX(), event.getY()));		}				private function getTipPosition(x:int, y:int):Point {			var position:Point = new Point(x + axes.getVertical().getWidth(), y - tip.height - 10);			if (position.x + tip.width > w) position.x -= tip.width;			if (position.y < 0) position.y = y + 10;			return position;		}				private function onHideTip(event:TipEvent):void {			tip.hide();		}				private function onMouseMove(event:MouseEvent = null):void {			var closest:Array = new Array();			for each (var s:Series in series) {				var c:Item = s.getClosest();				if (c != null) closest.push(c);			}			if (closest.length > 0) closest.sortOn("distance", Array.NUMERIC)[0].select();		}				private function onRemoveSeries(event:SeriesEvent):void {			var s:Series = event.getSeries();			if (s.isDeletable()) {				series.splice(s.getIndex(), 1);				removeChild(s);				axes.getVertical().resetExtremes();				for each (var s:Series in series) {					axes.getVertical().updateExtremes(s.getVerticalMin(), s.getVerticalMax());				}				ExternalInterface.call("setSliderMax", getMaxItemCount() - 1);			}		}			}	}