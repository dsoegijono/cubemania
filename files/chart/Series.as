package {		import flash.display.Sprite;	import flash.filters.DropShadowFilter;	import flash.events.MouseEvent;		public class Series extends Sprite {				private var title:String;		private var items:Array;		private var label:SeriesLabel;		private var axes:Axes;		private var color:int;		private var verticalMin:String;		private var verticalMax:String;				public function Series(data:XML, axes:Axes, index:int) {			this.axes = axes;			initColor(index);			parseData(data);			initLabel();			filters = [new DropShadowFilter(2, 45, 0x000000, 0.25)];		}				private function initColor(index:int):void {			var colors:Array = [0xFF0000, 0x00FF00, 0x0000FF];			color = colors[index % 3];			color |= colors[(index + Math.floor(index / 3)) % 3];			if (index >= 9) color *= Math.random();		}				private function parseData(data:XML):void {			title = data.@title;			items = new Array();			for each (var item:XML in data.item) {				addItem(item);			}		}				public function addItem(data:XML):Item {			var item:Item = new Item(data, axes, color);			if (int(item.getV()) < int(verticalMin) || verticalMin == null) verticalMin = item.getV();			if (int(item.getV()) > int(verticalMax) || verticalMax == null) verticalMax = item.getV();			items.push(item);			addChild(item);			return item;		}				private function initLabel():void {			label = new SeriesLabel(title, color);			label.addEventListener(MouseEvent.CLICK, onLabelClick);			label.visible = false;			addChild(label);		}				private function onLabelClick(event:MouseEvent):void {			dispatchEvent(new SeriesEvent(SeriesEvent.REMOVE, this));		}				public function draw():void {			if (items.length > 0) {				graphics.clear();				graphics.lineStyle(4, color);				items[0].draw();				graphics.moveTo(items[0].x, items[0].y);				for (var i:uint = 1; i < items.length; i++) {					var item:Item = items[i];					item.draw();					graphics.lineTo(item.x, item.y);				}				var maxPos:int = axes.getMaxHorizontalPosition();				var lastItem:Item = items[items.length - 1];				graphics.lineTo(maxPos, lastItem.y);				label.position(maxPos, lastItem.y);				label.visible = true;			}		}				public function getClosest():Item {			for each (var item:Item in items) {				item.deselect();			}			return items.concat().sortOn("distance", Array.NUMERIC)[0];		}				public function getHorizontalMin():String {			if (items.length == 0) return new Date().toString();			return items[0].getH();		}				public function getHorizontalMax():String {			if (items.length == 0) return new Date().toString();			return items[items.length - 1].getH();		}				public function getVerticalMin():String {			return verticalMin;		}				public function getVerticalMax():String {			return verticalMax;		}			}	}