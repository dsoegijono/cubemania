package {		import flash.display.Sprite;	import flash.filters.DropShadowFilter;	import flash.events.MouseEvent;	import flash.external.ExternalInterface;		public class Series extends Sprite {				private var title:String;		private var items:Array;		private var label:SeriesLabel;		private var axes:Axes;		private var color:int;		private var verticalMin:String;		private var verticalMax:String;				public function Series(data:XML, axes:Axes, index:int) {			this.axes = axes;			initColor(index);			parseData(data);			initLabel();			filters = [new DropShadowFilter(2, 45, 0x000000, 0.25)];		}				private function initColor(index:int):void {			var colors:Array = [0xFF0000, 0x00FF00, 0x0000FF];			color = colors[index % 3];			color |= colors[(index + Math.floor(index / 3)) % 3];			if (index >= 9) color *= Math.random();		}				private function parseData(data:XML):void {			title = data.@title;			items = new Array();			for each (var item:XML in data.item) {				addItem(item);			}		}				public function addItem(data:XML, isNew:Boolean = false):Item {			var item:Item = new Item(data, axes, color);			if (items.length <= axes.getItemCount()) {				if (int(item.getV()) < int(verticalMin) || verticalMin == null) verticalMin = item.getV();				if (int(item.getV()) > int(verticalMax) || verticalMax == null) verticalMax = item.getV();			}			isNew ? items.unshift(item) : items.push(item);			return item;		}				private function initLabel():void {			label = new SeriesLabel(title, color);			label.addEventListener(MouseEvent.CLICK, onLabelClick);			label.visible = false;			addChild(label);		}				private function onLabelClick(event:MouseEvent):void {			dispatchEvent(new SeriesEvent(SeriesEvent.REMOVE, this));		}				public function draw():void {			if (items.length > 0) {				removeItems();				graphics.clear();				graphics.lineStyle(4, color);				addChild(items[0]);				items[0].draw(0);				graphics.moveTo(items[0].x, items[0].y);				var count:int = getItemCount();				for (var i:uint = 1; i <= count; i++) {					var item:Item = items[i];					addChild(item);					item.draw(i);					graphics.lineTo(item.x, item.y);				}				var maxPos:int = axes.getMaxHorizontalPosition();				label.position(maxPos, items[0].y);				label.visible = true;			}		}				private function removeItems():void {			for each (var item:Item in items) {				if (contains(item)) removeChild(item);			}		}				private function getItemCount():int {			var count:int = axes.getItemCount();			if (count >= items.length) count = items.length - 1;			return count;		}				public function getClosest():Item {			var count:int = getItemCount();			for (var i:uint = 0; i <= count; i++) {				items[i].deselect();			}			var indexes:Array = axes.getClosestIndexes(mouseX);			if (indexes[1] >= items.length) {				return items[items.length - 1];			}			else {				var d1:int = Math.abs(mouseX - items[indexes[0]].x);				var d2:int = Math.abs(items[indexes[1]].x - mouseX);				return d1 < d2 ? items[indexes[0]] : items[indexes[1]];			}		}				public function getHorizontalMin():String {			if (items.length == 0) return new Date().toString();			return items[0].getH();		}				public function getHorizontalMax():String {			if (items.length == 0) return new Date().toString();			return items[items.length - 1].getH();		}				public function getVerticalMin():String {			return verticalMin;		}				public function getVerticalMax():String {			return verticalMax;		}				public function hasItems():Boolean {			return items.length > 0;		}			}	}